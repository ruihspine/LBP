dplyr::select(var_name) %>%
filter(location_name %in% 'China' &
age_name %in% age2 )
View(GBD_population)
#修整数据
GBD_population$age_name<-gsub(" years","",GBD_population$age_name)
View(GBD_population)
GBD_Male_population<- subset(GBD_population,
GBD_population$sex_name =="Male")
###### 2020-2030年人口学数据#####
prediction_var_name <- c("location_name", "sex", "year_id", "age_group_name", "val")
prediction_var_name
GBD_population_prediction <- fread("IHME_POP_2017_2100_POP_REFERENCE_Y2020M05D01.csv") %>%    # fread() 是 data.table 包中的函数，用于快速读取 CSV 文件。# 它读取文件 "IHME_POP_2017_2100_POP_REFERENCE_Y2020M05D01.csv"，这可能是某个研究机构发布的人口预测数据。
GBD_population_prediction <- fread("IHME_POP_2017_2100_POP_REFERENCE_Y2020M05D01.csv") %>%    # fread() 是 data.table 包中的函数，用于快速读取 CSV 文件。# 它读取文件 "IHME_POP_2017_2100_POP_REFERENCE_Y2020M05D01.csv"，这可能是某个研究机构发布的人口预测数据。
dplyr::select(prediction_var_name) %>%             #  选择特定的变量列（即 prediction_var_name），这些变量名应该在代码的其他地方定义，它们可能包括诸如 location_name, sex, year_id, age_group_name 和 val 等。
dplyr::filter(location_name %in% 'China' &         #  筛选条件：location_name %in% 'China'：只保留地区为 "China"（中国）的数据。
year_id %in% 2024:2040   &         #  只保留年份在 2022 到 2036 年之间的数据。
sex %in% "Male")
####读取筛选预测人口数据
GBD_population_prediction <- fread("IHME_POP_2017_2100_POP_REFERENCE_Y2020M05D01.csv") %>%    # fread() 是 data.table 包中的函数，用于快速读取 CSV 文件。# 它读取文件 "IHME_POP_2017_2100_POP_REFERENCE_Y2020M05D01.csv"，这可能是某个研究机构发布的人口预测数据。
dplyr::select(prediction_var_name) %>%             #  选择特定的变量列（即 prediction_var_name），这些变量名应该在代码的其他地方定义，它们可能包括诸如 location_name, sex, year_id, age_group_name 和 val 等。
dplyr::filter(location_name %in% 'China' &         #  筛选条件：location_name %in% 'China'：只保留地区为 "China"（中国）的数据。
year_id %in% 2024:2040   &         #  只保留年份在 2022 到 2036 年之间的数据。
sex %in% "Male")                   #  sex %in% "Male"：只保留性别为 "Male"（男性）的数据。
View(GBD_population_prediction)
View(GBD_population_prediction)
unique(GBD_population_prediction$age_group_name)
View(IBD_in_both)
#行命名
rownames(IBD_in_both_n) <- IBD_in_both_n$year
View(IBD_in_both_n)
GBD_population  <-  data.frame()
#names(GBD_population) = var_name
path = "./GBD_population"
fileName = dir(path)
fileName
GBD_population <- data.frame()
GBD_population<-GBD_population%>%
dplyr::select(var_name) %>%
filter(location_name %in% 'China' &
age_name %in% age2 )
# install.packages("remotes")
# install.packages("foreach")
# install.packages("cmprsk")
# install.packages("fanplot")
# install.packages("Epi")
# install.packages("caTools")
# install.packages("sp")
library("cmprsk")
library("remotes")
library("foreach")
library("fanplot")
library("Epi")
library("caTools")
library("sp")
##### 下载后安装nordpred、INLA包，在本地安装
# install.packages("openxlsx")
# install.packages("reshape")
# install.packages("data.table")
# install.packages("tidyr")
# install.packages("tidyverse")
# install.packages("epitools")
# install.packages("ggplot2")
library(openxlsx)
library(reshape)
library(data.table)
library(tidyr)
library(tidyverse)
library(epitools)
library(ggplot2)
library(BAPC)
library(INLA)
#inla.upgrade() # for the stable version
# 1990-2019年人口学数据
# 发病数据需要的年龄分层
age1 <- c("<5 years","5-9 years","10-14 years","15-19 years","20-24 years",
"25-29 years","30-34 years","35-39 years","40-44 years","45-49 years",
"50-54 years","55-59 years","60-64 years","65-69 years","70-74 years",
"75-79 years","80-84 years","85-89 years","90-94 years","95+ years")   ###20个年龄组
#### 调取标准人口百分比用
ages_2 <- c("<5 years","5-9 years","10-14 years","15-19 years","20-24 years",
"25-29 years","30-34 years","35-39 years","40-44 years","45-49 years",
"50-54 years","55-59 years","60-64 years","65-69 years","70-74 years",
"75-79 years","80-84 years","85-89 years","90-94 years","95+ years")
####  预测的年龄结构
ages_3 <- c("0 to 4", "5 to 9","10 to 14", "15 to 19","20 to 24", "25 to 29",
"30 to 34", "35 to 39", "40 to 44", "45 to 49", "50 to 54", "55 to 59",
"60 to 64", "65 to 69", "70 to 74", "75 to 79", "80 to 84", "85 to 89",
"90 to 94", "95 plus")
# 标准年龄结构数据age_stand
age_stand <- read.csv("2023_age_stand.csv")
sum(age_stand$std_population)
# 1. 计算合并的0-4岁组标准化人口数
#sum_0_4 <- sum(as.numeric(age_stand$std_population[1:2]))
# 2. 提取5-9岁至95+岁各组的标准化人口数
#ages_5_plus <- as.numeric(age_stand$std_population[3:21])
# 3. 组合成新的人口分组向量
#new_pop_groups <- c(sum_0_4, ages_5_plus)
# 4. 计算总标准化人口数
#total_pop <- sum(as.numeric(age_stand$std_population[1:21]))
# 5. 计算各新分组的构成比（占总人口比例）
#wstand <- new_pop_groups / total_pop
#新数据从"<5 years"开始，只需要 [1:20] 而不是 [1:21]，老数据小于1，1-4，后续如果数据不一样可以给ai处理生成新代码
#标准构成比
wstand <- c(
age_stand$std_population[1] %>% as.numeric(),   # 第1组（<5 years）
age_stand$std_population[2:20] %>% as.numeric() # 第2-20组（5-9 years 到 95+ years）
) / sum(age_stand$std_population[1:20] %>% as.numeric())
# 输出标准构成比
wstand
# 检查标准构成比的总和是否为1，确保计算正确
sum(wstand)
IBD_china <- read.csv('IBD_china.csv')
########Both#######
####Incidence####
#####先处理发生人数数据#####
IBD_in_both<- subset(IBD_china,
(IBD_china$age_name %in% age1) &
IBD_china$sex_name=="Male"&
IBD_china$location_name=='China'&
IBD_china$metric_name== 'Number' &
IBD_china$measure_name=='Incidence') #这些指标可以改
# 发病数据需要的年龄分层
#  age1 <- c("<5 years","5-9 years","10-14 years","15-19 years","20-24 years",
#            "25-29 years","30-34 years","35-39 years","40-44 years","45-49 years",
#            "50-54 years","55-59 years","60-64 years","65-69 years","70-74 years",
#            "75-79 years","80-84 years","85-89 years","90-94 years","95+ years")   ###20个年龄组
unique(IBD_in_both$age_name)
IBD_in_both$age_name<-gsub(" years","",IBD_in_both$age_name)
IBD_in_both$age_name <- factor(IBD_in_both$age_name,
levels = c("<5", "5-9", "10-14", "15-19",
"20-24", "25-29", "30-34", "35-39", "40-44", "45-49", "50-54",
"55-59", "60-64", "65-69", "70-74", "75-79", "80-84", "85-89",
"90-94", "95+"))
# 提取数据Measure_name,age_name,year,val
IBD_in_both <- IBD_in_both[,c("measure_name", "age_name","year","val")]
#长转宽
IBD_in_both_n <- reshape2::dcast(data=IBD_in_both, #  reshape2::dcast()：将数据从长格式转换为宽格式，适用于以某个变量为行，另一个变量为列的情况。
year ~ age_name,  #  指定 year 作为行，age_name 作为列。
value.var="val")  # value.var = "val"：指定 val 列中的数据作为新表中每个单元格的值。
# 最终结果 IBD_in_both_n 是一个宽格式的数据框，其中行是不同的年份，列是不同的年龄组，每个单元格对应特定年份和年龄组的发病人数。
#行命名
rownames(IBD_in_both_n) <- IBD_in_both_n$year
#删除第一列
IBD_in_both_n <- IBD_in_both_n[,-1]
#IBD_in_both_n <- apply(IBD_in_both_n,c(1,2),as.integer) %>% as.data.frame
####含义####四舍五入并且转换成数据狂
IBD_in_both_n <- apply(IBD_in_both_n,
c(1,2),round) %>%
as.data.frame
#  解释：apply(IBD_in_both_n, c(1, 2), round)：apply() 是一个 R 函数，适用于矩阵或数据框。
#  c(1, 2)：指定对数据的每一行和每一列应用函数。1 表示按行操作，2 表示按列操作，c(1, 2) 表示对矩阵的每个元素应用函数。
#  round：这是要应用的函数，它对每个数值进行四舍五入。因此，这段代码会对 IBD_in_both_n 中的每个元素进行四舍五入;
#  %>%：管道操作符，将 apply() 的输出作为 as.data.frame 的输入。as.data.frame：将四舍五入后的结果转换为数据框。
#  总结：这段代码的作用是对 IBD_in_both_n 中的每个数值元素进行四舍五入，并将处理后的结果转换为数据框格式。
####人口数据#####
###人口数据
age2 <- c("<5 years","5-9 years","10-14 years","15-19 years","20-24 years",
"25-29 years","30-34 years","35-39 years","40-44 years","45-49 years",
"50-54 years","55-59 years","60-64 years","65-69 years","70-74 years",
"75-79 years","80-84 years","85-89 years","90-94 years","95+ years")   ###20个年龄
var_name <- c("location_name", "sex_name", "year", "age_name", "val")
GBD_population  <-  data.frame()
#names(GBD_population) = var_name
path = "./GBD_population"
fileName = dir(path)
fileName
GBD_population <- data.frame()
#population<-data.frame()
for(k in 1:length(fileName)){
data = fread(file = paste(path,fileName[k],sep = "/"))
GBD_population=rbind(GBD_population,data)
}
GBD_population<-GBD_population%>%
dplyr::select(var_name) %>%
filter(location_name %in% 'China' &
age_name %in% age2 )
View(GBD_population)
#修整数据
GBD_population$age_name<-gsub(" years","",GBD_population$age_name)
GBD_Male_population<- subset(GBD_population,
GBD_population$sex_name =="Male")
###### 2020-2030年人口学数据#####
prediction_var_name <- c("location_name", "sex", "year_id", "age_group_name", "val")
GBD_population_prediction <- fread("IHME_POP_2017_2100_POP_REFERENCE_Y2020M05D01.csv") %>%    # fread() 是 data.table 包中的函数，用于快速读取 CSV 文件。# 它读取文件 "IHME_POP_2017_2100_POP_REFERENCE_Y2020M05D01.csv"，这可能是某个研究机构发布的人口预测数据。
dplyr::select(prediction_var_name) %>%             #  选择特定的变量列（即 prediction_var_name），这些变量名应该在代码的其他地方定义，它们可能包括诸如 location_name, sex, year_id, age_group_name 和 val 等。
dplyr::filter(location_name %in% 'China' &         #  筛选条件：location_name %in% 'China'：只保留地区为 "China"（中国）的数据。
year_id %in% 2024:2040   &         #  只保留年份在 2022 到 2036 年之间的数据。
sex %in% "Male")                   #  sex %in% "Male"：只保留性别为 "Male"（男性）的数据。
View(GBD_population_prediction)
unique(GBD_population_prediction$age_group_name)
View(GBD_population_prediction)
GBD_5year <- GBD_population_prediction %>%
filter(age_group_name %in% c("Early Neonatal","Late Neonatal", "Post Neonatal","1 to 4")) %>%    #  这一步筛选出年龄组为 "Early Neonatal"（早期新生儿）、"Late Neonatal"（晚期新生儿）、"Post Neonatal"（新生儿后期）和 "1 to 4"（1到4岁）的数据。这些年龄组数据将被合并为一个新的年龄组, 即"<5" 这个新的年龄组。
group_by(location_name,sex,year_id) %>%     #  对筛选后的数据按地区 (location_name)、性别 (sex)、年份 (year_id) 进行分组。这个分组操作是为了在后续的 summarise() 中对每个分组计算总和。例如，中国的男性人口数据在 2022 年的小于5岁的这几类年龄组会被分为一个组，方便进一步操作。
summarise(val=sum(val)) %>%                 #  在每个分组中，summarise() 函数将 val 列中的数值进行求和，计算不同年龄组的总人口数。比如，对于某一年，"Early Neonatal"、"Late Neonatal"、"Post Neonatal" 和 "1 to 4" 这些年龄组的人口会相加，得到总的 <5 人口数。例如：对于某一年，合并后的 <5 人口数等于各年龄段（新生儿阶段和 1-4 岁）的总和。
#  含义：val = sum(val)：这里 summarise() 对每个分组的数据进行操作，将变量 val 的数值进行汇总（求和）。具体来说：val 是你要操作的变量，它可能表示人口数量。sum(val) 计算每个分组中 val 列的总和（即将相同地区、性别、年份内，不同年龄组的人口数加起来）。使用场景：计算总和：如你的代码中，将特定分组内的数值相加。计算均值：你也可以使用 mean() 来计算某一变量的平均值。计算计数：可以使用 n() 来计算每个分组中有多少行。
mutate(age_group_name="<5")                 #   为新生成的数据添加一个新的变量或修改现有变量。在这一步，将新分组后的这些数据的年龄组名称都设置为 "<5"，表示该组是小于5岁的人口。
GBD_population_prediction <- GBD_population_prediction %>%
filter(!(age_group_name %in% c("Early Neonatal","Late Neonatal", "Post Neonatal","All Ages","1 to 4"))) %>%     #  这一步使用 filter() 函数来筛选数据，保留不在 c("Early Neonatal", "Late Neonatal", "Post Neonatal", "All Ages", "1 to 4") 列表中的年龄组。!（取反运算符）：表示排除这些年龄组的数据。这意味着，GBD_population_prediction 数据集中属于这些年龄组的行会被删除。这些被排除的年龄组已经在前面的步骤中汇总到 <5 这个年龄组，所以不再需要保留它们。
rbind(GBD_5year)                 #  rbind(GBD_5year)：rbind() 函数用于将两个数据框按行合并。GBD_5year 是之前汇总得到的新的 <5 岁年龄组的数据集，表示小于5岁的人口总数。通过 rbind()，将这个 <5 岁的数据合并到已经过滤的 GBD_population_prediction 数据集中。总结：这段代码的作用是先删除 GBD_population_prediction 数据集中和 <5 岁相关的原始年龄组数据（包括早期新生儿、晚期新生儿、1到4岁等），然后将之前通过汇总生成的 <5 岁人口数据（即 GBD_5year）合并到数据集中。最终，GBD_population_prediction 会包含新的 <5 岁人口数据，同时保留其他不受影响的年龄组的数据。
names(GBD_population_prediction)[names(GBD_population_prediction) == 'age_group_name'] <- 'age_name'
GBD_population_prediction$age_name<-gsub(" to ","-",GBD_population_prediction$age_name)
View(GBD_population_prediction)
GBD_population_prediction$age_name<-gsub(" to ","-",GBD_population_prediction$age_name)
GBD_population_prediction$age_name<-gsub(" plus","+",GBD_population_prediction$age_name)
unique(GBD_population_prediction$age_name)
colnames(GBD_population_prediction)<-var_name
var_name
View(GBD_Male_population)
#####合并人口学数据1990-2036#####
GBD <- rbind(GBD_Male_population, GBD_population_prediction)
View(GBD)
GBD$age_name<-factor(GBD$age_name, levels = c("<5", "5-9", "10-14", "15-19",
"20-24", "25-29", "30-34", "35-39", "40-44", "45-49", "50-54",
"55-59", "60-64", "65-69", "70-74", "75-79", "80-84", "85-89",
"90-94", "95+"))
unique(GBD$age_name)
GBD_China_Male <- subset(GBD,
location_name=="China" &
sex_name=="Male")
GBD_China_Male$age_name<-factor(GBD_China_Male$age_name,
levels = c("<5", "5-9", "10-14", "15-19", "20-24",
"25-29", "30-34", "35-39", "40-44", "45-49",
"50-54", "55-59", "60-64", "65-69", "70-74",
"75-79", "80-84", "85-89", "90-94", "95+"))
GBD_China_Male_n <- dcast(data=GBD_China_Male,
year~age_name,
value.var=c("val")) %>%
as.data.frame()
View(GBD_China_Male_n)
#改行名
rownames(GBD_China_Male_n) <- GBD_China_Male_n$year
GBD_China_Male_n <- GBD_China_Male_n[,-1]
GBD_China_Male_n <- GBD_China_Male_n[,-1]
GBD_China_Male_n <- apply(GBD_China_Male_n,
c(1,2),
as.numeric) %>% as.data.frame()
GBD_China_Male_n <- apply(GBD_China_Male_n,
c(1,2),
round) %>% as.data.frame()
IBD_pro <- matrix(data=NA,                             #  使用 matrix() 函数创建一个矩阵，参数 data = NA 表示矩阵中的所有初始值为 NA，即缺失值。这个矩阵相当于一个空白表格，等待填充数据。
nrow=2040-2023,                      #  指定矩阵的行数为 2036 - 2021，即 15 行。这意味着矩阵的每一行代表一个年份，从 2022 年到 2036 年。不是16行.
ncol=ncol(GBD_China_Male_n)) %>%     #  ncol() 函数用于获取数据框 GBD_China_Male_n 的列数(20)。GBD_China_Male_n 的列数(20)应该对应不同的年龄组，这一步是确保新创建的矩阵 IBD_pro 的列数与 GBD_China_Male_n 相同。例如，如果 GBD_China_Male_n 有 20 个年龄组，那么 IBD_pro 也会有 20 列，每列将来会用来存储相应年龄组的预测数据。
as.data.frame()                      #  as.data.frame()：使用管道操作符 %>% 将 matrix() 创建的矩阵转换为标准的 R 数据框格式，以便更容易进行后续的数据操作。矩阵和数据框的区别在于数据框支持更复杂的数据结构，且更适合数据分析。
rownames(IBD_pro) <- seq(2024, 2040, 1)
colnames(IBD_pro) <- names(IBD_in_both_n)
colnames(IBD_pro) <- names(IBD_in_both_n)
library("cmprsk")
library("remotes")
library("foreach")
library("fanplot")
library("Epi")
library("caTools")
library("sp")
library(openxlsx)
library(reshape)
library(data.table)
library(tidyr)
library(tidyverse)
library(epitools)
library(ggplot2)
library(BAPC)
library(INLA)
# 发病数据需要的年龄分层
age1 <- c("<5 years","5-9 years","10-14 years","15-19 years","20-24 years",
"25-29 years","30-34 years","35-39 years","40-44 years","45-49 years",
"50-54 years","55-59 years","60-64 years","65-69 years","70-74 years",
"75-79 years","80-84 years","85-89 years","90-94 years","95+ years")   ###20个年龄组
#### 调取标准人口百分比用
ages_2 <- c("<5 years","5-9 years","10-14 years","15-19 years","20-24 years",
"25-29 years","30-34 years","35-39 years","40-44 years","45-49 years",
"50-54 years","55-59 years","60-64 years","65-69 years","70-74 years",
"75-79 years","80-84 years","85-89 years","90-94 years","95+ years")
####  预测的年龄结构
ages_3 <- c("0 to 4", "5 to 9","10 to 14", "15 to 19","20 to 24", "25 to 29",
"30 to 34", "35 to 39", "40 to 44", "45 to 49", "50 to 54", "55 to 59",
"60 to 64", "65 to 69", "70 to 74", "75 to 79", "80 to 84", "85 to 89",
"90 to 94", "95 plus")
library("cmprsk")
library("remotes")
library("foreach")
library("fanplot")
library("Epi")
library("caTools")
library("sp")
library(openxlsx)
library(reshape)
library(data.table)
library(tidyr)
library(tidyverse)
library(epitools)
library(ggplot2)
library(BAPC)
library(INLA)
# 发病数据需要的年龄分层
age1 <- c("<5 years","5-9 years","10-14 years","15-19 years","20-24 years",
"25-29 years","30-34 years","35-39 years","40-44 years","45-49 years",
"50-54 years","55-59 years","60-64 years","65-69 years","70-74 years",
"75-79 years","80-84 years","85-89 years","90-94 years","95+ years")   ###20个年龄组
#### 调取标准人口百分比用
ages_2 <- c("<5 years","5-9 years","10-14 years","15-19 years","20-24 years",
"25-29 years","30-34 years","35-39 years","40-44 years","45-49 years",
"50-54 years","55-59 years","60-64 years","65-69 years","70-74 years",
"75-79 years","80-84 years","85-89 years","90-94 years","95+ years")
####  预测的年龄结构
ages_3 <- c("0 to 4", "5 to 9","10 to 14", "15 to 19","20 to 24", "25 to 29",
"30 to 34", "35 to 39", "40 to 44", "45 to 49", "50 to 54", "55 to 59",
"60 to 64", "65 to 69", "70 to 74", "75 to 79", "80 to 84", "85 to 89",
"90 to 94", "95 plus")
# 标准年龄结构数据age_stand
age_stand <- read.csv("age_stand.csv")
sum(age_stand$std_population)
#标准构成比
wstand <- c(
age_stand$std_population[1] %>% as.numeric(),   # 第1组（<5 years）
age_stand$std_population[2:20] %>% as.numeric() # 第2-20组（5-9 years 到 95+ years）
) / sum(age_stand$std_population[1:20] %>% as.numeric())
# 输出标准构成比
wstand
# 检查标准构成比的总和是否为1，确保计算正确
sum(wstand)
IBD_china <- read.csv('global number.csv')
View(IBD_china)
IBD_in_both<- subset(IBD_china,
(IBD_china$age_name %in% age1) &
IBD_china$sex_name=="Both"&
IBD_china$location_name=='Global'&
IBD_china$metric_name== 'Number' &
IBD_china$measure_name=='Incidence') #这些指标可以改
View(IBD_in_both)
unique(IBD_in_both$age_name)
IBD_in_both$age_name<-gsub(" years","",IBD_in_both$age_name)
IBD_in_both$age_name <- factor(IBD_in_both$age_name,
levels = c("<5", "5-9", "10-14", "15-19",
"20-24", "25-29", "30-34", "35-39", "40-44", "45-49", "50-54",
"55-59", "60-64", "65-69", "70-74", "75-79", "80-84", "85-89",
"90-94", "95+"))
# 提取数据Measure_name,age_name,year,val
IBD_in_both <- IBD_in_both[,c("measure_name", "age_name","year","val")]
#长转宽
IBD_in_both_n <- reshape2::dcast(data=IBD_in_both, #  reshape2::dcast()：将数据从长格式转换为宽格式，适用于以某个变量为行，另一个变量为列的情况。
year ~ age_name,  #  指定 year 作为行，age_name 作为列。
value.var="val")  # value.var = "val"：指定 val 列中的数据作为新表中每个单元格的值。
View(IBD_in_both_n)
#行命名
rownames(IBD_in_both_n) <- IBD_in_both_n$year
#删除第一列
IBD_in_both_n <- IBD_in_both_n[,-1]
####含义####四舍五入并且转换成数据狂
IBD_in_both_n <- apply(IBD_in_both_n,
c(1,2),round) %>%
as.data.frame
####人口数据#####
###人口数据
age2 <- c("<5 years","5-9 years","10-14 years","15-19 years","20-24 years",
"25-29 years","30-34 years","35-39 years","40-44 years","45-49 years",
"50-54 years","55-59 years","60-64 years","65-69 years","70-74 years",
"75-79 years","80-84 years","85-89 years","90-94 years","95+ years")   ###20个年龄
var_name <- c("location_name", "sex_name", "year", "age_name", "val")
View(GBD)
GBD_population <- read.csv('population.csv')
View(GBD_population)
###人口数据进行筛选，china中age2同样的年龄段
GBD_population<-GBD_population%>%
dplyr::select(var_name) %>%
filter(location_name %in% 'Global' &
age_name %in% age2 )
View(GBD_population)
#修整数据
GBD_population$age_name<-gsub(" years","",GBD_population$age_name)
GBD_Male_population<- subset(GBD_population,
GBD_population$sex_name =="Both")
View(GBD_Male_population)
###### 2020-2030年人口学数据#####
prediction_var_name <- c("location_name", "sex", "year_id", "age_group_name", "val")
####读取筛选预测人口数据
GBD_population_prediction <- fread("IHME_POP_2017_2100_POP_REFERENCE_Y2020M05D01.csv") %>%    # fread() 是 data.table 包中的函数，用于快速读取 CSV 文件。# 它读取文件 "IHME_POP_2017_2100_POP_REFERENCE_Y2020M05D01.csv"，这可能是某个研究机构发布的人口预测数据。
dplyr::select(prediction_var_name) %>%             #  选择特定的变量列（即 prediction_var_name），这些变量名应该在代码的其他地方定义，它们可能包括诸如 location_name, sex, year_id, age_group_name 和 val 等。
dplyr::filter(location_name %in% 'Global' &         #  筛选条件：location_name %in% 'China'：只保留地区为 "China"（中国）的数据。
year_id %in% 2024:2040   &         #  只保留年份在 2022 到 2036 年之间的数据。
sex %in% "Both")                   #  sex %in% "Male"：只保留性别为 "Male"（男性）的数据。
View(GBD_population_prediction)
library(dplyr)
POPULATION<- read.csv('IHME_POP_2017_2100_POP_REFERENCE_Y2020M05D01.csv')
POPULATION_both <- POPULATION %>%
# 按location_id, age_group_id, year_id分组
group_by(location_id, location_name, age_group_id, age_group_name, year_id) %>%
# 对每个分组，计算Male和Female的val之和
summarise(
val = sum(val[sex %in% c("Female", "Male")], na.rm = TRUE),
.groups = "drop"
) %>%
# 添加sex列，值为"Both"
mutate(sex = "Both") %>%
# 重新排列列的顺序
select(location_id, location_name, sex, age_group_id, age_group_name, year_id, val)
View(POPULATION_both)
write.csv(POPULATION_both,
file = "POPULATION_both.csv",
row.names = FALSE,  # 不保存行号
na = "",            # 将NA值保存为空字符串
fileEncoding = "UTF-8")  # 设置编码，防止中文乱码
GBD_population_prediction <- POPULATION_both%>%   #fread("IHME_POP_2017_2100_POP_REFERENCE_Y2020M05D01.csv") %>%    # fread() 是 data.table 包中的函数，用于快速读取 CSV 文件。# 它读取文件 "IHME_POP_2017_2100_POP_REFERENCE_Y2020M05D01.csv"，这可能是某个研究机构发布的人口预测数据。
dplyr::select(prediction_var_name) %>%             #  选择特定的变量列（即 prediction_var_name），这些变量名应该在代码的其他地方定义，它们可能包括诸如 location_name, sex, year_id, age_group_name 和 val 等。
dplyr::filter(location_name %in% 'Global' &         #  筛选条件：location_name %in% 'China'：只保留地区为 "China"（中国）的数据。
year_id %in% 2024:2040   &         #  只保留年份在 2022 到 2036 年之间的数据。
sex %in% "Both")
View(GBD_population_prediction)
unique(GBD_population_prediction$age_group_name)
GBD_5year <- GBD_population_prediction %>%
filter(age_group_name %in% c("Early Neonatal","Late Neonatal", "Post Neonatal","1 to 4")) %>%    #  这一步筛选出年龄组为 "Early Neonatal"（早期新生儿）、"Late Neonatal"（晚期新生儿）、"Post Neonatal"（新生儿后期）和 "1 to 4"（1到4岁）的数据。这些年龄组数据将被合并为一个新的年龄组, 即"<5" 这个新的年龄组。
group_by(location_name,sex,year_id) %>%     #  对筛选后的数据按地区 (location_name)、性别 (sex)、年份 (year_id) 进行分组。这个分组操作是为了在后续的 summarise() 中对每个分组计算总和。例如，中国的男性人口数据在 2022 年的小于5岁的这几类年龄组会被分为一个组，方便进一步操作。
summarise(val=sum(val)) %>%                 #  在每个分组中，summarise() 函数将 val 列中的数值进行求和，计算不同年龄组的总人口数。比如，对于某一年，"Early Neonatal"、"Late Neonatal"、"Post Neonatal" 和 "1 to 4" 这些年龄组的人口会相加，得到总的 <5 人口数。例如：对于某一年，合并后的 <5 人口数等于各年龄段（新生儿阶段和 1-4 岁）的总和。
#  含义：val = sum(val)：这里 summarise() 对每个分组的数据进行操作，将变量 val 的数值进行汇总（求和）。具体来说：val 是你要操作的变量，它可能表示人口数量。sum(val) 计算每个分组中 val 列的总和（即将相同地区、性别、年份内，不同年龄组的人口数加起来）。使用场景：计算总和：如你的代码中，将特定分组内的数值相加。计算均值：你也可以使用 mean() 来计算某一变量的平均值。计算计数：可以使用 n() 来计算每个分组中有多少行。
mutate(age_group_name="<5")                 #   为
View(GBD_5year)
GBD_population_prediction <- GBD_population_prediction %>%
filter(!(age_group_name %in% c("Early Neonatal","Late Neonatal", "Post Neonatal","All Ages","1 to 4"))) %>%     #  这一步使用 filter() 函数来筛选数据，保留不在 c("Early Neonatal", "Late Neonatal", "Post Neonatal", "All Ages", "1 to 4") 列表中的年龄组。!（取反运算符）：表示排除这些年龄组的数据。这意味着，GBD_population_prediction 数据集中属于这些年龄组的行会被删除。这些被排除的年龄组已经在前面的步骤中汇总到 <5 这个年龄组，所以不再需要保留它们。
rbind(GBD_5year)                 #  rbind(GBD_5year)：rbind() 函数用于将两个数据框按行合并。GBD_5year 是之前汇总得到的新的 <5 岁年龄组的数据集，表示小于5岁的人口总数。通过 rbind()，将这个 <5 岁的数据合并到已经过滤的 GBD_population_prediction 数据集中。总结：这段代码的作用是先删除 GBD_population_prediction 数据集中和 <5 岁相关的原始年龄组数据（包括早期新生儿、晚期新生儿、1到4岁等），然后将之前通过汇总生成的 <5 岁人口数据（即 GBD_5year）合并到数据集中。最终，GBD_population_prediction 会包含新的 <5 岁人口数据，同时保留其他不受影响的年龄组的数据。
names(GBD_population_prediction)[names(GBD_population_prediction) == 'age_group_name'] <- 'age_name'
GBD_population_prediction$age_name<-gsub(" to ","-",GBD_population_prediction$age_name)
GBD_population_prediction$age_name<-gsub(" plus","+",GBD_population_prediction$age_name)
unique(GBD_population_prediction$age_name)
colnames(GBD_population_prediction)<-var_name
#####合并人口学数据1990-2036#####
GBD <- rbind(GBD_Male_population, GBD_population_prediction)
GBD$age_name<-factor(GBD$age_name, levels = c("<5", "5-9", "10-14", "15-19",
"20-24", "25-29", "30-34", "35-39", "40-44", "45-49", "50-54",
"55-59", "60-64", "65-69", "70-74", "75-79", "80-84", "85-89",
"90-94", "95+"))
unique(GBD$age_name)
View(GBD)
View(GBD)
GBD_China_Male <- subset(GBD,
location_name=="Global" &
sex_name=="Both")
GBD_China_Male$age_name<-factor(GBD_China_Male$age_name,
levels = c("<5", "5-9", "10-14", "15-19", "20-24",
"25-29", "30-34", "35-39", "40-44", "45-49",
"50-54", "55-59", "60-64", "65-69", "70-74",
"75-79", "80-84", "85-89", "90-94", "95+"))
View(GBD_China_Male)
GBD_China_Male_n <- dcast(data=GBD_China_Male,
year~age_name,
value.var=c("val")) %>%
as.data.frame()
setDT(GBD_China_Male)
GBD_China_Male_n <- dcast(data=GBD_China_Male,
year~age_name,
value.var=c("val")) %>%
as.data.frame()
#改行名
rownames(GBD_China_Male_n) <- GBD_China_Male_n$year
View(GBD_China_Male_n)
GBD_China_Male_n <- GBD_China_Male_n[,-1]
GBD_China_Male_n <- apply(GBD_China_Male_n,
c(1,2),
as.numeric) %>% as.data.frame()
###取整数
GBD_China_Male_n <- apply(GBD_China_Male_n,
c(1,2),
round) %>% as.data.frame()
# 补充没有发病人数数据的年份
IBD_pro <- matrix(data=NA,                             #  使用 matrix() 函数创建一个矩阵，参数 data = NA 表示矩阵中的所有初始值为 NA，即缺失值。这个矩阵相当于一个空白表格，等待填充数据。
nrow=2040-2023,                      #  指定矩阵的行数为 2036 - 2021，即 15 行。这意味着矩阵的每一行代表一个年份，从 2022 年到 2036 年。不是16行.
ncol=ncol(GBD_China_Male_n)) %>%     #  ncol() 函数用于获取数据框 GBD_China_Male_n 的列数(20)。GBD_China_Male_n 的列数(20)应该对应不同的年龄组，这一步是确保新创建的矩阵 IBD_pro 的列数与 GBD_China_Male_n 相同。例如，如果 GBD_China_Male_n 有 20 个年龄组，那么 IBD_pro 也会有 20 列，每列将来会用来存储相应年龄组的预测数据。
as.data.frame()                      #  as.data.frame()：使用管道操作符 %>% 将 matrix() 创建的矩阵转换为标准的 R 数据框格式，以便更容易进行后续的数据操作。矩阵和数据框的区别在于数据框支持更复杂的数据结构，且更适合数据分析。
View(IBD_pro)
rownames(IBD_pro) <- seq(2024, 2040, 1)
colnames(IBD_pro) <- names(IBD_in_both_n)
IBD_pro_n <- rbind(IBD_in_both_n, IBD_pro)
View(IBD_in_both_n)
View(IBD_pro)
View(GBD_China_Male_n)
# 补充没有发病人数数据的年份
IBD_pro <- matrix(data=NA,                             #  使用 matrix() 函数创建一个矩阵，参数 data = NA 表示矩阵中的所有初始值为 NA，即缺失值。这个矩阵相当于一个空白表格，等待填充数据。
nrow=2040-2023,                      #  指定矩阵的行数为 2036 - 2021，即 15 行。这意味着矩阵的每一行代表一个年份，从 2022 年到 2036 年。不是16行.
ncol=ncol(IBD_in_both_n)) %>%
#ncol=ncol(GBD_China_Male_n)) %>%     #  ncol() 函数用于获取数据框 GBD_China_Male_n 的列数(20)。GBD_China_Male_n 的列数(20)应该对应不同的年龄组，这一步是确保新创建的矩阵 IBD_pro 的列数与 GBD_China_Male_n 相同。例如，如果 GBD_China_Male_n 有 20 个年龄组，那么 IBD_pro 也会有 20 列，每列将来会用来存储相应年龄组的预测数据。
as.data.frame()                      #  as.data.frame()：使用管道操作符 %>% 将 matrix() 创建的矩阵转换为标准的 R 数据框格式，以便更容易进行后续的数据操作。矩阵和数据框的区别在于数据框支持更复杂的数据结构，且更适合数据分析。
rownames(IBD_pro) <- seq(2024, 2040, 1)
colnames(IBD_pro) <- names(IBD_in_both_n)
IBD_pro_n <- rbind(IBD_in_both_n, IBD_pro)
IBD_pro_n <- apply(IBD_pro_n,
c(1,2),
as.numeric) %>%
as.data.frame()
IBD_pro_n <- apply(IBD_pro_n,
c(1,2),
round) %>%
as.data.frame()
require(INLA)
View(IBD_pro_n)
View(GBD_China_Male_n)
View(GBD_China_Male_n)
IBD_input <- APCList(IBD_pro_n,
GBD_China_Male_n[3:5],
gf=5)##gf为年份间隔
IBD_bapc_result <- BAPC(IBD_input,
predict=list(npredict=17, retro=T),
secondDiff=FALSE,
stdweight=wstand[3:5],
verbose=F)
agespec.proj(IBD_bapc_result)
p1<-plotBAPC(IBD_bapc_result,
scale=10^5,
type = 'ageStdRate',
showdata = TRUE)
#提取数据
Male_de =data.frame(IBD_bapc_result@agestd.rate)
write.csv(Male_de,file = "Male_de.csv")
